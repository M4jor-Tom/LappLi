package com.muller.lappli.domain.interfaces;

import com.muller.lappli.domain.*;
import com.muller.lappli.domain.enumeration.AssemblyPresetDistribution;
import java.lang.reflect.InvocationTargetException;
import java.util.List;

/**
 * An interface which grants access to formulas.
 * Those can either come from a target instance,
 * in which case they could be secret, or a default instance,
 * which is just here to allow the program's compilation
 */
public interface ICalculator {
    /**
     * Tries to find the class in targetCalculatorInstanceClassName
     *
     * If it is found, instanciate it.
     *
     * Otherwise returns instanceReturnedIfTargetNotFound
     *
     * @param targetCalculatorInstanceClassName the class name which is tried
     * to instanciate
     * @param instanceReturnedIfTargetNotFound the object returned if
     * no class was found with targetCalculatorInstanceClassName
     * @return the instance of ICalculator
     */
    public static ICalculator getNewInstance(String targetCalculatorInstanceClassName, ICalculator instanceReturnedIfTargetNotFound) {
        try {
            return (ICalculator) Class.forName(targetCalculatorInstanceClassName).getConstructor().newInstance();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (
            InstantiationException
            | IllegalAccessException
            | IllegalArgumentException
            | InvocationTargetException
            | NoSuchMethodException
            | SecurityException e
        ) {
            e.printStackTrace();
        }

        return instanceReturnedIfTargetNotFound;
    }

    /**
     * Returns true from instance of {@link CalculatorManager#TARGET_CALCULATOR_INSTANCE_CLASS_NAME},
     * and false from empty implementations
     *
     * @return a Boolean
     */
    public Boolean isTargetCalculatorInstance();

    //  ASSEMBLY PART

    /**
     * Calculates the diameter of the central void generated by an assembly,
     * mesured in components average diameter.
     *
     * @param suppliedComponentsCount the count of suppliedComponents which are
     * just around the center
     *
     * @param diameterAssemblyStep the assembly step in diameters with which the
     * assembly is done
     *
     * @return the central diameter
     */
    public Double getSuppliedComponentsAverageDiameterCentralVoidDiameter(Long suppliedComponentsCount, Double diameterAssemblyStep);

    /**
     * Calculates the diameter of the central void generated by the assembly
     * mesured in milimeters which will be resulted from Strand's
     * supplied components counts and the forcing of a central utility component
     *
     * @param strandSupply the protagonist strandSupply
     * @return the central diameter
     */
    public default Double getMilimeterCentralVoidDiameter(StrandSupply strandSupply) {
        AssemblyPresetDistributionPossibility assemblyPresetDistributionPossibility = strandSupply.getAssemblyPresetDistributionPossibility();

        if (assemblyPresetDistributionPossibility == null) {
            return Double.NaN;
        }

        Long indexOfFirst3OrMoreComposedCoreAssembly = Long.valueOf(0);

        if (assemblyPresetDistributionPossibility.getFirstAssemblyPreset().isCentralAccordingToTotalComponentsCount()) {
            indexOfFirst3OrMoreComposedCoreAssembly = Long.valueOf(1);
        }

        return (
            strandSupply.getStrand().getSuppliedComponentsAverageMilimeterDiameter() *
            getSuppliedComponentsAverageDiameterCentralVoidDiameter(
                getSuppliesCountAtAssembly(strandSupply, indexOfFirst3OrMoreComposedCoreAssembly),
                strandSupply.getDiameterAssemblyStep()
            )
        );
    }

    /**
     * Calculates the amount of supplied components at a given assembly
     *
     * @param strandSupply the strandSupply in which we have to calculate
     * the amount of supplied components in a given assembly
     *
     * @param assemblyIndex the index of the given assembly
     *
     * @return the amount of supplied components at a given assembly index
     */
    public Long getSuppliesCountAtAssembly(StrandSupply strandSupply, Long assemblyIndex);

    /**
     * Generates a new AssemblyPresetDistributionPossibility which represents
     * the best fit for the cable
     *
     * @param strandSupply the StrandSupply to describe
     * @return an AssemblyPresetDistributionPossibility which describes its Assemblies
     * at best
     */
    public AssemblyPresetDistributionPossibility getAssemblyPresetDistributionPossibility(StrandSupply strandSupply);

    /**
     * Calculates the assembly void at the given Assembly for the Strand
     *
     * @param strandSupply the StrandSupply to analyse
     * @param assemblyIndex the index of the Assembly to analyse
     * @return the assembly void in the analysed Assembly
     */
    public Double getSuppliedComponentsAverageDiameterAssemblyVoid(StrandSupply strandSupply, Long assemblyIndex);

    /**
     * Same as {@link ICalculator#getSuppliedComponentsAverageDiameterAssemblyVoid},
     * but the result is in milimeters
     *
     * @param strandSupply the protagonist StrandSupply
     * @param assemblyIndex the assembly index at which we check the assembly void
     * @return the assembly void in the analysed Assembly in milimeters
     */
    public default Double getMilimeterAssemblyVoid(StrandSupply strandSupply, Long assemblyIndex) {
        return (
            getSuppliedComponentsAverageDiameterAssemblyVoid(strandSupply, assemblyIndex) *
            strandSupply.getStrand().getSuppliedComponentsAverageMilimeterDiameter()
        );
    }

    /**
     * Suggests a components count for one layer depending
     * on parameters
     * @param centralDiameterInRoundComponentsDiameter how much
     * components diameter are required to get one central diameter
     * @param diameterAssemblyStep the assembly step measured in diameters
     * @return a count
     */
    public Double suggestSuppliedComponentsCount(Double centralDiameterInRoundComponentsDiameter, Double diameterAssemblyStep);

    /**
     * Same than {@link ICalculator#suggestSuppliedComponentsCount},
     * with diameters in milimeter to input rather than a ratio
     * @param centralMilimeterDiameter the diameter of the central component
     * @param roundComponentsAverageDiameter the diameter of components arount
     * @param diameterAssemblyStep the assembly step in diameters
     * @return a count
     */
    public Double suggestSuppliedComponentsCountWithMilimeterDiameters(
        Double centralMilimeterDiameter,
        Double roundComponentsAverageDiameter,
        Double diameterAssemblyStep
    );

    /**
     * Shows {@link com.muller.lappli.domain.AssemblyPresetDistributionPossibility}s
     * of the protagonist AssemblyPresetDistribution
     * @param assemblyPresetDistribution the protagonist assemblyPresetDistribution
     * @return a List of AssemblyPresetDistributionPossibilities
     */
    public List<AssemblyPresetDistributionPossibility> getAssemblyPresetDistributionPossibilitiesForAssemblyPresetDistribution(
        AssemblyPresetDistribution assemblyPresetDistribution
    );

    /**
     * Finds the IAssemblyPresetDistributionCalculator corresponding to the
     * protagonist assemblyPresetDistribution. It can be used to get more information.
     * @param assemblyPresetDistribution
     * @return a IAssemblyPresetDistributionCalculator
     */
    public IAssemblyPresetDistributionCalculator getCorrespondingAssemblyPresetDistributionCalculator(
        AssemblyPresetDistribution assemblyPresetDistribution
    );

    /**
     * The amount of existnig {@link com.muller.lappli.domain.interfaces.IAssemblyPresetDistributionCalculator}
     * @return a count
     */
    public Long getAssemblyPresetDistributionCalculatorCount();

    //  CARRIER_PLAIT PART

    /**
     * Compute the real Load (DN) of a CarrierPlait
     * @param carrierPlait the protagonist carrier plait
     * @return a Load in Deca Newtons
     */
    public Double getCarrierPlaitRealDecaNewtonLoad(CarrierPlait carrierPlait);

    /**
     * Computes the final diameter after this operation
     * @param carrierPlait the protagonist CarrierPlait
     * @param plaiterConfiguration the selected PlaiterConfiguration for the carrierPlait
     * @return a diameter in milimeters
     */
    public Double getAfterCarrierPlaitMilimeterDiameter(CarrierPlait carrierPlait, PlaiterConfiguration plaiterConfiguration);

    /**
     * Computes the minimum required CarrierPlaitFibers needed
     * for specified data in carrierPlait
     * @param carrierPlait the protagonist CarrierPlait
     * @return a count
     */
    public Long getMinimumCarrierPlaitFibersCount(CarrierPlait carrierPlait);

    /**
     * Calculates the times needed to prepare the
     * production of the operation
     * @param carrierPlait the protagonist CarrierPlait
     * @return a time in hours
     */
    public Double getCarrierPlaitHourPreparationTime(CarrierPlait carrierPlait);

    /**
     * Calculates an execution time needed to choose fastest
     * PlaiterConfiguration. It's not the true one.
     * @param carrierPlait the protagonist CarrierPlait
     * @param plaiterConfiguration the PlaiterConfiguration to test
     * @return a time in hours
     */
    public Double getCarrierPlaitInternalHourExecutionTime(CarrierPlait carrierPlait, PlaiterConfiguration plaiterConfiguration);

    /**
     * Calculates the time of the fastest plaiterConfiguration
     * for the CarrierPlait
     * @param carrierPlait the protagonist CarrierPlait
     * @return a time in hours
     */
    public Double getCarrierPlaitDisplayedHourExecutionTime(CarrierPlait carrierPlait);

    //TODO: javadoc this one
    public Double getPlaiterBobinCapacity(Plaiter plaiter);
}
